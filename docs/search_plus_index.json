{"./":{"url":"./","title":"简介","keywords":"","body":"简介 这是张昊的基础知识库，用来记录工作与学习中遇到的知识点 该文档不定期更新 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/IntelME/Intel_ME.html":{"url":"Chapter/IntelME/Intel_ME.html","title":"Intel ME 相关","keywords":"","body":"Intel ME 相关操作 查看ME Power命令 向ME发送指令可以有两种方式，如下所示，一种使用send command指令，一种直接指定bus和slaver address，推荐使用第二种 ipmitool -I lanplus -H BMCIP -U admin -P admin raw 0x06 0x34 0x46 0x2c 0xb8 0x1c 0x20 0x10 0xc8 0x57 0x01 0x00 0x01 0x00 0x00 0xaf ipmitool -I lanplus -H BMCIP -U admin -P admin -b 6 -t 0x2c raw 0x2e 0xc8 0x57 0x01 0x00 0x01 0x00 0x00 查看CPU/MEM CUPS命令 ipmitool -I lanplus -H BMCIP -U admin -P admin -b 6 -t 0x2c raw 0x04 0x2d 0xbe(0xc0) be为CPU的，c0为MEM的 返回值fc 40 c0 第一位就是对应的占用率,换算方式为（0xfc/0xff）*100 设置ME Power Policy的另外一种方式 注意：参照Node Manager 4.0文档，domain ID在前，policy ID在后,并且只有在Policy Control、Domain Control、Global Control同时enable时候才能生效 domain ID： =00h – Entire platform. =01h – CPU subsystem. =02h – Memory subsystem. =03h – HW Protection*. =04h – High Power I/O subsystem 1.内存功耗读取： ipmitool -b 6 -t 0x2c raw 0x2e 0xc8 0x57 0x01 0x00 0x01 0x02 0x00 2.设置内存功耗（Domain ID在前，Policy ID在后） 1) Disable Node Manager Policy Control ipmitool -b 6 -t 0x2c raw 0x2e 0xc0 0x57 0x01 0x00 0x00 0x02 0x04 2)Create NM Policy ipmitool -b 6 -t 0x2c raw 0x2e 0xc1 0x57 0x01 0x00 0x02 0x04 0x10 0x00 $WATT 0x00 0xe8 0x03 0x00 0x00 $WATT 0x00 0x01 0x00 3)Enable Node Manager Policy ipmitool -b 6 -t 0x2c raw 0x2e 0xc0 0x57 0x01 0x00 0x05 0x02 0x04 Enable Policy Control ipmitool -b 6 -t 0x2c raw 0x2e 0xc0 0x57 0x01 0x00 0x03 0x02 0x04 Enable Domain Control ipmitool -b 6 -t 0x2c raw 0x2e 0xc0 0x57 0x01 0x00 0x01 0x02 0x04 Enable Global Control 3.查询Policy ID的使能情况 ipmitool -b 6 -t 0x2c raw 0x2e 0xc2 0x57 0x01 0x00 0x02 0x04 返回值查看Byte5,前四位表示各种策略的enable情况，后四位表示Domain ID 刷新BIOS前后的动作 根据Node Manager 4.0文档 第24页内容： 刷新前下0x01命令，刷新后下0x02命令 DFh命令 01 ME进入Recovery Mode的指令 ipmitool -I -H -U -P -t 0x2c -b 6 -t 0x2c raw 0x2e 0xdf 0x57 0x01 0x00 0x01 ipmitool -I -H -U -P raw 0x06 0x34 0x46 0x2c 0xb8 0x1c 0x20 0x10 0xdf 0x57 0x01 0x00 0x01 02 ME离开Recovery Mode并重启的命令 ipmitool -I -H -U -P -t 0x2c -b 6 -t 0x2c raw 0x2e 0xdf 0x57 0x01 0x00 0x02 ipmitool -I -H -U -P raw 0x06 0x34 0x46 0x2c 0xb8 0x1c 0x20 0x10 0xdf 0x57 0x01 0x00 0x02 03 查询ME状态指令 ipmitool -I lanplus -H -U -P -t 0x2c -b 0x06 raw 0x06 0x04 ME selftest result ME Restart与ME Global Reset ME Restart 这个命令有时候比ME Global Reset好用,0x02表示回复ME default value ipmitool -b 6 -t 0x2c raw 0x2e 0xdf 0x57 0x01 0x00 0x02 设置ME Power Policy失败的一种原因 设置ME Power Policy的时候有时候会设置不进去，发送ME Power Policy命令返回0x84错误码，表示Power Limit out of range 这个是由于ME存在设定功耗的最小值与最大值，这个最小值与最大值可以通过命令获得，命令如下 ipmitool -b 6 -t 0x2c raw 0x2e 0xc9 0x57 0x01 0x00 0x01 0x10 其中倒数第二位表示domain ID；Byte 5[3:0]用于控制获得的值表示的含义，[6:4] – Policy Type表示电源的某种工作模式，默认使用0x10 返回值中的 Byte 6:7 Max Power/Thermal/Time After Reset Byte 8:9 – Min Power/Thermal/Time After Reset 当指令中的功耗值不在这个范围内就会产生0x84的错误码 获取ME中RTC的时间 获取ME中RTC的时间指令，回复的指令为LSB ipmitool -I -H -U -P -b 6 -t 0x2c raw 0x0a 0x48 最大值和最小值可以通过0xCB这条命令设置，注意，设置后可能导致ME限定功耗功能不能使用，一定慎用 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/Introduce.html":{"url":"Chapter/BMC/Introduce.html","title":"BMC 相关","keywords":"","body":"BMC相关 本章节涉及BMC相关的操作与指令 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/YafuFlash.html":{"url":"Chapter/BMC/YafuFlash.html","title":"YafuFlash工具","keywords":"","body":"编译YafuFlash工具的方法 MDS中修改存放在MDS安装目录下的workspace/software/yafuflash-x.x.x-ANY,编译用到的source存放在development/software/yafuflash-x.x.x-ANY 1.Yafulash编译过程中会出现MAX_NAME_LEN未定义的问题，在workspace/software/yafuflash-x.x.x-ANY/Commom/Include/main.h中添加宏定义#define MAX_NAME_LEN 256 2.编译过程中会出现IDBG_LINUXAPP_AuditOut无法连接的问题，需要在libipmi/libipmi_AMIOEM.c文件中注释掉出现TAUDIT的两行，目前是3782和3786行 3.正常编译会缺少相关依赖的库和文件，需要进入workspace/software/libipmi_sw-x.x.x-ANY/Linux目录下执行sudo make clean, sudo make all, sudo make install 这样就能在workspace/software目录下编译出相关的库文件 4.这个时候再进入workspace/software/yafuflash-x.x.x-ANY/目录下相关平台的目录中，执行sudo make clean, sudo make all 编译成功就可以在 workspace/software/yafuflash-x.x.x-ANY/obj目录中产生二进制文件 YafuFlash刷新BMC ./Yafuflash -nw -ip BMCIP -u USER -p PASSWORD -force-boot BMC.ima 加入-force-boot能够不用输入y Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/Sensor.html":{"url":"Chapter/BMC/Sensor.html","title":"Sensor相关","keywords":"","body":"Sensor Initialization与Sensor Capabilities 主要用于Sensor的初始化和表现 Sensor Initialization通常设置为0x77 [7] - reserved. Write as 0b. [6] - Init Scanning 1b = enable scanning (this bit=1b implies that the sensor accepts the ‘enable/disable scanning’ bit in the Set Sensor Event Enable command). 开启扫描模式，受到Set Sensor Event Enable命令中的enable/disable scanning位的影响 [5] - Init Events 1b = enable events (per Sensor Event Message Control Support bits in Sensor Capabilities field, and per the Event Mask fields) 开启记录SEL功能 [4] - reserved. Write as 0b. [3] - Init Hysteresis 1b = initialize sensor hysteresis (per Sensor Hysteresis Support bits in the Sensor Capabilities field) 还不清楚，好像和Capabilities有关 [2] - Init Sensor Type 1b = initialize Sensor Type and Event / Reading Type code 初始化Sensor Type和Event / Reading Type code Sensor Default (power up) State Reports how this sensor comes up on device power up and hardware/cold reset. The Initialization Agent does not use this bit. This bit solely reports to software how the sensor comes prior to being initialized by the Initialization Agent. [1] - 0b = event generation disabled, 1b = event generation enabled [0] - 0b = sensor scanning disabled, 1b = sensor scanning enabled Sensor Capabilities通常设置为0x40 [7] - 1b = ignore sensor if Entity is not present or disabled. 0b = don’t ignore sensor. Sensor Auto Re-arm Support Indicates whether the sensor requires manual rearming, or automatically rearms itself when the event clears. ‘manual’ implies that the get sensor event status and rearm sensor events commands are supported [6] - 0b = no (manual), 1b = yes (auto) Sensor Hysteresis Support [5:4] - 00b = No hysteresis, or hysteresis built-in but not specified. 01b = hysteresis is readable. 10b = hysteresis is readable and settable. 11b = Fixed, unreadable, hysteresis. Hysteresis fields values implemented in the sensor. Sensor Threshold Access Support [3:2] - 00b = no thresholds. 01b = thresholds are readable, per Reading Mask, below. 10b = reserved 11b = Fixed, unreadable, thresholds. Which thresholds are supported is reflected by the Reading Mask. The threshold value fields report the values that are ‘hard-coded’ in the sensor. Sensor Event Message Control Support Indicates whether this sensor generates Event Messages, and if so, what type of Event Message control is offered. [1:0] - 00b = per threshold/discrete-state event enable/disable control (implies that entire sensor and global disable are also supported) 01b = entire sensor only (implies that global disable is also supported) 10b = global disable only 11b = no events from sensor 设置了这一项就不会产生任何SEL Assert & Deassert 典型设置值0x7015,0x7a95 0x7015 只有Lower的方式记日志，Upper的方式不记日志 0x7a95 超过高的还有低的都记日志 [15] reserved write 0 [14] write 0 [13] write 0 [12] write 0 [11] assertion for upper non-recoverable going high supported 超过UNR [10] assertion for upper non-recoverable going low supported 低于UNR [09] assertion for upper critical going high supported 超过UC [08] assertion for upper critical going low supported 低于UC [07] assertion for upper non-critical going high supported 超过UNC [06] assertion for upper non-critical going low supported 低于UNC [05] assertion for lower non-recoverable going high supported 超过LNR [04] assertion for lower non-recoverable going low supported 低于LNR [03] assertion for lower critical going high supported 超过LC [02] assertion for lower critical going low supported 低于LC [01] assertion for lower non-critical going high supported 超过LNC [00] assertion for lower non-critical going low supported 低于LNC Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/FRU.html":{"url":"Chapter/BMC/FRU.html","title":"FRU相关","keywords":"","body":"FRU简介 FRU的初始化是作为一个sensor，在libipmimsghndlr/Sensor.c中的506行,有关FRU的设置宏定义存放在ipmipdk_dev/PDKFRU.h中，主要是FRU的类型和FRU的大小 刷写FRU中的某个部分 单独修改FRU的一项内容 ipmitool -I lanplus -H xx.xx.xx.xx -U admin -P admin fru edit field - edit FRU string Example: ipmitool -I lanplus -H 10.0.22.95 -U admin -P admin fru edit 0 field p 0x00 Sugon p for Product Area c for Chassis Area b for Board Area 所使用到的编号就是fru list的结果，从0x00开始排序,后边接的是要修改的字符串或者数字 FRU报错的一种原因 FRU这个sensor的Modify Type要设置成0x02,否则ipmitool fru会在echo $?时候会报错误1 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/UUID.html":{"url":"Chapter/BMC/UUID.html","title":"刷写UUID","keywords":"","body":"BMC刷写UUID BMC刷写UUID主要更改的是EEPROM中的内容，需要先行打开EEPROM的写保护才可以正常写入，此功能具体取决于主板设计 //设置写保护 ipmitool -I lanplus -H 10.0.22.115 -U admin -P admin raw 0x3a 0x30 0x2e 0x00 0x01 //设置方向 ipmitool -I lanplus -H 10.0.22.115 -U admin -P admin raw 0x3a 0x30 0x2e 0x01 0x00 //设置高低电平 //开始写入数据 ipmitool -I lanplus -H 10.0.22.115 -U admin -P admin raw 0x06 0x52 0x07 0xa0 0x00 0xf0 0xa0 0x86 0x31 0x1d ipmitool -I lanplus -H 10.0.22.115 -U admin -P admin raw 0x06 0x52 0x07 0xa0 0x00 0xf4 0x22 0xc0 ipmitool -I lanplus -H 10.0.22.115 -U admin -P admin raw 0x06 0x52 0x07 0xa0 0x00 0xf6 0x22 0xc0 ipmitool -I lanplus -H 10.0.22.115 -U admin -P admin raw 0x06 0x52 0x07 0xa0 0x00 0xf8 0xbd 0xdc ipmitool -I lanplus -H 10.0.22.115 -U admin -P admin raw 0x06 0x52 0x07 0xa0 0x00 0xfa 0x34 0x97 0xf6 0x00 0xdb 0x88 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/ChipLED.html":{"url":"Chapter/BMC/ChipLED.html","title":"箱耳LED相关操作","keywords":"","body":"此部分文档只适用于JGS相关搭配箱耳的机型 箱耳点亮led 1.配置I/O模式 i2c-test -b 1 -s 0x41 -m 1 -w -d 0x03 0x00 //配置全部为输出模式 2.点亮LED i2c-test -b 1 -s 0x41 -m 1 -w -d 0x01 0x00 //第一个数据表示寄存器地址，01表示输出寄存器，第二位表示所有灯的状态，3个灯分别对应第0，1,2位，该位0表示亮灯，1表示灭灯 箱耳显示数字 i2c-test -b 1 -s 0x34 -m 1 -w -d 0x7f //i2c地址可以调，分别是0x34 0x35 0x36 -d后边接的是转换过的数字 {'0', 0x3f}, {'1', 0x06}, {'2', 0x5b}, {'3', 0x4f}, {'4', 0x66}, {'5', 0x6d}, {'6', 0x7d}, {'7', 0x07}, {'8', 0x7f}, {'9', 0x6f}, {'C', 0x39}, {'P', 0x73}, {'F', 0x71}, {'H', 0x76}, {'B', 0x7f}, {'A', 0x77}, {'E', 0x79} Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/User.html":{"url":"Chapter/BMC/User.html","title":"用户与用户组","keywords":"","body":"使用ipmitool设置用户 1.设置用户名 ipmitool -I lanplus -H -U -P user set name (user number) (user name) ex:ipmitool -I lanplus -H 10.0.22.80 -U admin -P admin user set name 0x03 sugon 2.设置用户密码 ipmitool -I lanplus -H -U -P user set password (user number) (user password) ex:ipmitool -I lanplus -H 10.0.22.80 -U admin -P admin user set password 0x03 11111111 3.设置用户权限 ipmitool -I lanplus -H -U -P user priv (user number) (user priv) (channel number) channel number user 1 or 8 ipmitool -I lanplus -H -U -P raw 0x06 0x43 (channel number) (user number) (user priv) raw command channel number: channel 1 0xb1 channel 8 0xb8 注意:当使用bond的时候只设置channel 1的权限就可以，当使用非bond的时候，必须channel 1和8同时设置 ex:ipmitool -I lanplus -H 10.0.22.80 -U admin -P admin user priv 0x03 0x04 0x01 ipmitool -I lanplus -H 10.0.22.80 -U admin -P admin user priv 0x03 0x04 0x08 ipmitool -I lanplus -H 10.0.22.80 -U admin -P admin raw 0x06 0x43 0xb1 0x03 0x04 ipmitool -I lanplus -H 10.0.22.80 -U admin -P admin raw 0x06 0x43 0xb8 0x03 0x04 4.使能用户 ipmitool -I lanplus -H -U -P user enable (user number) ex:ipmitool -I lanplus -H 10.0.22.80 -U admin -P admin user enable 0x03 5.设置用户拓展权限 ipmitool -I lanplus -H -U -P raw 0x32 0xa3 (user number) 0x03 0x00 0x00 0x00 ipmitool -I lanplus -H -U -P raw 0x32 0x7d (user number) 0x01 0x02 0x01 0x01 ex:ipmitool -I lanplus -H 10.0.22.80 -U admin -P admin raw 0x32 0xa3 0x03 0x03 0x00 0x00 0x00 ex:ipmitool -I lanplus -H 10.0.22.80 -U admin -P admin raw 0x32 0x7d 0x03 0x01 0x02 0x01 0x01 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/Time.html":{"url":"Chapter/BMC/Time.html","title":"时间与时区","keywords":"","body":"通过IPMITOOL设置BMC时间 ipmitool设置BMC时间的时候会根据系统的时间设置一个带有时区的时间戳给BMC，同时BMC中会将时区设为0，导致后续时间的错误，为了减少此类问题的影响，ipmitool设置BMC时间的时候应该遵循下方的过程 1.ipmitool设置时间的时候应该在正确的localtime基础上减去一个时区时间 2.ipmitool设置完时间后一定要再次设置时区 example:设置时间为2018/01/15 17:00:00 1.ipmitool -I lanplus -H 10.0.22.31 -U admin -P admin sel time set \"01/15/2017 09:00:00\" //在17点的基础上减去当前时区8小时 2.ipmitool -I lanplus -H 10.0.22.31 -U admin -P admin raw 0x0a 0x5d 0xe0 0x01 //设置时区为8小时(480分钟) 3.ipmitool -I lanplus -H 10.0.22.31 -U admin -P admin sel time get //返回时间为 01/15/2017 18:00:32 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/Storage.html":{"url":"Chapter/BMC/Storage.html","title":"存储系统","keywords":"","body":"编译Storelib库 storelib的修改内容(SAS卡部分)： 1.需要修改slcommon.c中i2c的库文件名以及通信的函数名称，原始为slir3_bmc_i2c.so、master_write_on_bus、writeread_on_bus，需要改为/usr/local/lib/libi2c.so、i2c_master_write_on_bus、i2c_writeread_on_bus 2.不能修改slinternal.h中规定的debug使用的目录文件名称，必须保持slit3combo_bmc_conf.ini、slit3combo_bmc_debug.txt，如果需要修改目录可以按照如下的方法修改，修改sllinux.h中的SL_LINUX_DBG_FILE_PATH宏定义修改为\"/var/log\"，然后在挂在的ini文件中修改DEBUGDIR=/var/log,可以达到同样的修改debug日志路径的目的 3.需要将slinternal.h中的DEFAULT_I2C_BMC_I2C_ADDRESS改为5 4.需要切换slMCTP.h中i2c的完整性验证为FALSE，SL_INTEGRITY_CHECK SL_FALSE 5.需要修改transpI2CMsg.h中的宏定义修改为#define DEFAULT_I2C_MAX_WRITE_SIZE 64， #define DEFAULT_I2C_MAX_READ_SIZE 64， #define DEFAULT_I2C_MAX_READWRITE_SIZE 36，同时需要修改ini_conf文件中对应的三个宏定义 硬盘状态 存储系统的硬盘有一个状态叫做Foreign，该状态表示这个硬盘在其他的Raid卡上做过Raid，但是又更换了控制器,可以用如下指令清空该状态 /opt/MegaRAID/storcli/storcli64 /c0 /fall del SIGPIPE信号 产生SIGPIPE信号的问题研究 产生原因：对于一个PIPE或者FIFO的写操作，如果是以非阻塞方式只写方式(O_WRONLY)打开的管道，在读端关闭以后，如果还向管道中写数据，则会产生SIGPIPE的信息 避免方式：在PIPE或者FIFO写端打开的时候，指定打开的权限为读写方式(O_WRRD)，这样即使关闭了读端的管道，写数据仍然不会出现SIGPIPE，但是可能造成数据的错位 Raid级别 RAID0 这种配置至少需要1块硬盘支持 RAID 0是最早出现的RAID模式，即Data Stripping数据分条技术。RAID 0是组建磁盘阵列中最简单的一种形式，只需要2块以上的硬盘即可，成本低，可以提高整个磁盘的性能和吞吐量。RAID 0没有提供冗余或错误修复能力，但实现成本是最低的。 RAID 0实现方式就是把N块同样的硬盘用硬件的形式通过智能磁盘控制器或用操作系统中的磁盘驱动程序以软件的方式串联在一起创建一个大的卷集。其读写性能均得到较好的提升，如使用了三块100GB的硬盘组建成RAID 0模式，那么磁盘容量就会是300GB；而速度方面，各单独一块硬盘的速度完全相同。最大的缺点在于RAID 0没有容错能力，任何一块硬盘出现故障，整个系统将会受到破坏，可靠性仅为单独一块硬盘的1/N。 RAID1 这种配置至少需要2块硬盘支持 RAID 1称为磁盘镜像，原理是把一个磁盘的数据镜像到另一个磁盘上，也就是说数据在写入一块磁盘的同时，会在另一块闲置的磁盘上生成镜像文件，在不影响性能情况下最大限度的保证系统的可靠性和可修复性上，只要系统中任何一对镜像盘中至少有一块磁盘可以使用，甚至可以在一半数量的硬盘出现问题时系统都可以正常运行,当一块硬盘失效时，系统会忽略该硬盘，转而使用剩余的镜像盘读写数据，具备很好的磁盘冗余能力 RAID5 RAID 5（分布式奇偶校验的独立磁盘结构） 这种配置至少需要3块硬盘支持 从它的示意图上可以看到，它的奇偶校验码存在于所有磁盘上，其中的p0代表第0带区的奇偶校验值，其它的意思也相同。RAID5的读出效率很高，写入效率一般，块式的集体访问效率不错。因为奇偶校验码在不同的磁盘上，所以提高了可靠性。但是它对数据传输的并行性解决不好，而且控制器的设计也相当困难。RAID 3 与RAID 5相比，重要的区别在于RAID 3每进行一次数据传输，需涉及到所有的阵列盘。而对于RAID 5来说，大部分数据传输只对一块磁盘操作，可进行并行操作。在RAID 5中有“写损失”，即每一次写操作，将产生四个实际的读/写操作，其中两次读旧的数据及奇偶信息，两次写新的数据及奇偶信息. RAID6 这种配置至少需要4块硬盘支持 RAID6全称为Independent Data Disks with two Independent Distributed Darity Schemes（带有两个独立分布式校验方案的独立数据磁盘） RAID 6技术是在RAID 5基础上，为了进一步加强数据保护而设计的一种RAID方式，实际上是一种扩展RAID 5等级。与RAID 5的不同之处于除了每个硬盘上都有同级数据XOR校验区外，还有一个针对每个数据块的XOR校验区,RAID 6 是在RAID-5基础上把校验信息由一位增加到两位的RAID级别。 RAID6的优点是快速的读取性能，更高的容错能力；而它的缺点是很慢的写入速度，RAID控制器在设计上更加复杂，成本更高。 RAID10 这种配置至少需要4块硬盘支持 RAID 10是一个RAID 1与RAID 0的组合体，它是利用奇偶校验实现条带集镜像，所以它继承了RAID 0的快速和RAID 1的安全。我们知道，RAID 1在这里就是一个冗余的备份阵列，而RAID 0则负责数据的读写阵列。它的优点是同时拥有RAID 0的超凡速度和RAID 1的数据高可靠性，但是CPU占用率同样也更高，而且磁盘的利用率比较低。由于利用了RAID 0极高的读写效率和RAID 1较高的数据保护、恢复能力，使RAID 10成为了一种性价比较高的等级，目前几乎所有的RAID控制卡都支持这一等级。但是，RAID 10对存储容量的利用率和RAID 1一样低，只有50%。因此，RAID10即高可靠性与高效磁盘结构它是一个带区结构加一个镜象结构，可以达到既高效又高速的目的，RAID 10能提供比RAID 5更好的性能。这种新结构的可扩充性不好，这种解决方案被广泛应用，使用此方案比较昂贵。 RAID50 它具有RAID 5和RAID 0的共同特性。它由两组RAID 5磁盘组成（每组最少3个），每一组都使用了分布式奇偶位，而两组硬盘再组建成RAID 0，实现跨磁盘抽取数据。RAID 50提供可靠的数据存储和优秀的整体性能，并支持更大的卷尺寸。即使两个物理磁盘发生故障（每个阵列中一个），数据也可以顺利恢复过来。RAID 50最少需要6个驱动器，它最适合需要高可靠性存储、高读取速度、高数据传输性能的应用。这些应用包括事务处理和有许多用户存取小文件的办公应用程序。 利用Storecli改变物理硬盘状态 1.查看当前所有物理磁盘状态 /opt/MegaRAID/storcli/storcli64 /c0 /eall /sall show all 2.修改某块磁盘状态 /opt/MegaRAID/storcli/storcli64 /cx /ex /sx set good/offline/online/missing 从JBOD修改为UG需要单独加入一个参数 force /opt/MegaRAID/storcli/storcli64 /c0 /e69 /s7 set good force 3.初始化某个磁盘 /opt/MegaRAID/storcli/storcli64 /cx /ex /sx start initialization 4.查看某个初始化的物理磁盘进度 /opt/MegaRAID/storcli/storcli64 /cx /ex /sx show initialization 5.定位某块物理磁盘 /opt/MegaRAID/storcli/storcli64 /cx /ex /sx start locate Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-09 14:07:50 "},"Chapter/BMC/SEL.html":{"url":"Chapter/BMC/SEL.html","title":"SEL与注错","keywords":"","body":"BIOS推送重启日志 BIOS推送OS重启的SEL指令如下，需要带内发送： ipmitool raw 0x0a 0x44 0x08 0x04 0x02 0 0 0 0 0x21 0x00 0x04 0x1d 0x28 0x6f 0x07 0x0a 0xff 内存注错 OEM SEL 注错 需要在系统下执行ipmitool command ipmitool raw 0x04 0x02 0x21 0x04 0x0c 0x0 0x6f 0xaf 0x00 0x00 //内存MRC错误 ipmitool raw 0x04 0x02 0x21 0x04 0x0c 0x0 0x6f 0xa0 0x00 0x00 //内存ECC错误 ipmitool raw 0x04 0x02 0x21 0x04 0x0c 0x0 0x6f 0xa1 0x00 0x00 //内存UECC错误 ipmitool raw 0x04 0x02 0x21 0x04 0x0c 0x0 0x6f 0xa5 0x00 0x00 //内存ECC Limit Reach错误 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/Network.html":{"url":"Chapter/BMC/Network.html","title":"NCSI与网络","keywords":"","body":"修改Dedicated Lan网口灯闪烁模式 文件：linux/drivers/net/ethernet/aspeed/ast_ether.c 第239行添加如下代码 //Set the PHY LED to the right Mode ast_ether_phy_write_register(dev, priv->phy_addr, 31, 0x0d04); ast_ether_phy_write_register(dev, priv->phy_addr, 31, 0x0d04); ast_ether_phy_write_register(dev, priv->phy_addr, 0x10, 0x091b); ast_ether_phy_write_register(dev, priv->phy_addr, 0x10, 0x091b); ast_ether_phy_write_register(dev, priv->phy_addr, 31, 0x0000); //Close Default EEE Mode ast_ether_phy_write_register(dev, priv->phy_addr, 31, 0x0d04); ast_ether_phy_write_register(dev, priv->phy_addr, 0x11, 0x0000); ast_ether_phy_write_register(dev, priv->phy_addr, 0x11, 0x0000); ast_ether_phy_write_register(dev, priv->phy_addr, 31, 0x0000); 修改MAC保存到EEPROM相关配置 文件：Bootloader_ex/spx/DEFCONFIG 最下方修改 /* I2C EEPROM (AT24C128) configuration */ #define CONFIG_I2C_CHANNEL_ID CONFIG_SPX_FEATURE_GLOBAL_UBOOT_ENABLE_I2C_BUS #define CONFIG_SYS_EEPROM_ADDR 0x50 #define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 2 /* Network Configuration */ #define CONFIG_MACADDR_IN_EEPROM #define CONFIG_CMD_EEPROM 0 #define CONFIG_EEPROM_MACADDR_OFFSET 0x0f00 #define CONFIG_EEPROM_MAC1ADDR_OFFSET 0x0f08 修改心跳灯软件模式 文件：uboot/arch/arm/cpu/astcommon/interrupts.c 注释掉50行开始的一部分代码 + /* Enable Software blinking mode */ + *(UINT32 *)(HW_HEART_BEAT_STATUS_REG) = ((*(UINT32 *)(HW_HEART_BEAT_STATUS_REG)) & 0xffffffef) | (1 BMC获取IP 使用BMC重新获取DHCP IP的命令 udhcp -b -i eth0 -p /var/run/udhcpc.pid -R 添加-R能够使得dhcp server重新分配ip Package ID 板载网卡的package ID为1，OCP-A网卡的package ID为0 Ping操作 指定网卡进行ping操作 ping -I eth1 10.0.22.54 白名单 清理白名单设置的指令 iptables -D INPUT -j DROP 端口测试 可以用以下命令进行端口是否开启的测试： sudo traceroute -n -T -p port HostIP 全部是*表示端口没有开启，如果能找到地址，说明端口已经开启 关闭与开启SSH服务 IPMITOOL关闭ssh服务 ipmitool -I lanplus -H 10.0.22.88 -U admin -P admin raw 0x32 0x6A 0x20 0x00 0x00 0x00 0x00 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x00 0xff 0xff 0xff 0xff 0x16 0x00 0x00 0x00 0x58 0x02 0x00 0x00 0xff 0x00 IPMITOOL开启ssh服务 ipmitool -I lanplus -H 10.0.22.88 -U admin -P admin raw 0x32 0x6A 0x20 0x00 0x00 0x00 0x01 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x46 0x00 0xff 0xff 0xff 0xff 0x16 0x00 0x00 0x00 0x58 0x02 0x00 0x00 0xff 0x00 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/RegMem.html":{"url":"Chapter/BMC/RegMem.html","title":"U-boot/Kernel/寄存器","keywords":"","body":"BMC寄存器 读取BMC寄存器设置的指令，BMC下使用如下指令 devmem address eg:devmem 0x1e6e2070 regmemapp eg:regmemapp -r -a 0x1e6e2070 -l 0x04 最好参照help信息，部分高地址会读不到 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/Tools.html":{"url":"Chapter/BMC/Tools.html","title":"工具","keywords":"","body":"上传spx包的命令 ./svnspx --spxconfig-file=./spxconfig-tpl --ci /home/liyongcheng/sprint-dev/sprint18/Project/SugonBase/new-uboot-spx/Bootloader_amiext_ex-2.47.0-src.spx --force-commit --non-interactive spx包命令 打开AMI spx包命令 python /usr/mds-4.0.1/spx/utils/PackSPX.py -x packagesname.spx outputdirname 打包source为AMI spx包命令 python /usr/mds-4.0.1/spx/utils/PackSPX.py -c sourcedirname packagesname.spx Java设置 JAVA环境配置安全等级 /usr/lib/jvm/jdk1.8.0_20/bin/ControlPanel Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/WebUI.html":{"url":"Chapter/BMC/WebUI.html","title":"网页","keywords":"","body":"网页编译目录 build dir /home/zhanghao/sugon/project/BaiduOEM170325/development/Build/.build/webui_html5-2.398.0-src/data/ tmp dir /home/zhanghao/sugon/project/BaiduOEM170325/development/Build/.workspace/tmp 中文设定 清除网页上的中文设定，否则某些异常退出的情况下由于cookie缓存造成BMC页面无法打开 localStorage.setItem('locale', 'root'); 用curl下载文件 //登陆 curl -X POST -d \"username=ADMIN&password=ADMIN\" \"http://10.0.22.31/api/session\" -c ./cookie //下载 curl -o test.txt -H \"X-CSRFTOKEN:ipMOdTeL\" \"http://10.0.22.31/baidu/maintenance/sol/dump\" -b ./cookie Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/BMC/PreTest.html":{"url":"Chapter/BMC/PreTest.html","title":"PreTest","keywords":"","body":"使用SIT的PreTest工具方法 环境相关信息： ip:10.0.27.98 username:root password:password pwd:/root/sugonPreTest 需要将准备测试的镜像放在Date文件中，并重新命名为bmc.ima command: python Main.py -D 10.0.22.88 -S 10.0.22.22 -N bmc.ima -F 3.72 python Main.py -D 10.0.22.51 -S 10.0.22.92 -N bmc.ima -F 3.72 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-07 14:06:03 "},"Chapter/Linux/Introduce.html":{"url":"Chapter/Linux/Introduce.html","title":"Linux系统","keywords":"","body":"Linux 相关 本章节设计使用Linux过程中的知识 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/Linux/crontab.html":{"url":"Chapter/Linux/crontab.html","title":"crontab","keywords":"","body":"crontab中date命令 crontab中的date命令使用的坑 1、习惯上的date +\"%Y%m%d_%H:%M\" 和 $(date +\"%Y%m%d%H:%M\")在crontab下不起作用，需采用如下形式 `date +\"\\%Y\\%m\\%d\\%H:\\%M\"` 和 $(date +\"\\%Y\\%m\\%d_\\%H:\\%M\") 2、直接在crontab里以sudo执行命令无效，会提示 sudo: sorry, you must have a tty to run sudo .需要修改/etc/sudoers，执行visudo或者vim /etc/sudoers 将\"Defaults requiretty\"这一行注释掉。因为sudo默认需要tty终端，而crontab里的命令实际是以无tty形式执行的。注释掉\"Defaults requiretty\"即允许以无终端方式执行sudo Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/Linux/svn.html":{"url":"Chapter/Linux/svn.html","title":"svn","keywords":"","body":"svn取消修改 取消对代码的修改分为两种情况： 第一种情况：改动没有被提交（commit） 这种情况下，使用svn revert就能取消之前的修改。 svn revert用法如下： # svn revert [-R] something 其中something可以是（目录或文件的）相对路径也可以是绝对路径。 当something为单个文件时，直接svn revert something就行了；当something为目录时，需要加上参数-R(Recursive,递归)，否则只会将something这个目录的改动。 在这种情况下也可以使用svn update命令来取消对之前的修改，但不建议使用。因为svn update会去连接仓库服务器，耗费时间。 注意：svn revert本身有固有的危险，因为它的目的是放弃未提交的修改。一旦你选择了恢复，Subversion没有方法找回未提交的修改。 第二种情况：改动已经被提交（commit）。 这种情况下，用svn merge命令来进行回滚。 回滚的操作过程如下： 1、保证我们拿到的是最新代码： svn update 2、然后找出要回滚的确切版本号： svn log to confirm version svn log 3、回滚到版本号： svn merge -r ori:des something svn merge -r 28:25 something 为了保险起见，再次确认回滚的结果： svn diff [something] 4、提交回滚： svn commit -m \"Revert revision from r28 to r25,because of ...\" 将以上操作总结为三条如下： 1. svn update，svn log，找到最新版本（latest revision） 2. 找到自己想要回滚的版本号（rollbak revision） 3. 用svn merge来回滚： svn merge -r : something svn历史版本 svn 查看历史信息 通过svn命令可以根据时间或修订号去除过去的版本，或者某一版本所做的具体的修改。以下四个命令可以用来查看svn 的历史： svn log 用来展示svn 的版本作者、日期、路径等等 svn diff 用来显示特定修改的行级详细信息 svn cat 取得在特定版本的某文件显示在当前屏幕 svn list 显示一个目录或某一版本存在的文件 (一）svn log可以显示所有的信息，如果只希望查看特定的某两个版本之间的信息，可以使用： svn log -r r1:r2 如果只想查看某一个文件的版本修改信息，可以使用 svn log A 如果希望得到目录的信息要加-v 如果希望显示限定N条记录的目录信息，使用 svn log --limit N -v （二）svn diff用来检查历史修改的详情 检查本地修改 比较工作拷贝与版本库 比较版本库与版本库 （1）如果用svn diff，不带任何参数，它将会比较你的工作文件与缓存在.svn的“原始”拷贝 （2）比较工作拷贝和版本库 svn diff -r 3 rule.txt，就是比较你的工作拷贝和版本库中版本号为3的文件rule.txt （3）比较版本库与版本库 通过-r(revision)传递两个通过冒号分开的版本号，这两个版本会进行比较 svn diff -r 2:3 rule.txt 用来比较svn工作版本中版本号2和3的这个文件的变化 （三）svn cat 如果只是希望检查一个过去版本，不希望查看他们的区别，可使用svn cat svn cat -r 版本号 rule,txt 这个命令会显示在该版本号下的该文件内容 （四）svn list svn list可以在不下载文件到本地目录的情况下来察看目录中的文件： 如果你希望察看详细信息，你可以使用--verbose(-v) 参数： 这些列告诉你文件和目录最后修改的修订版本、做出修改的用户、如果是文件还会有文件的大小，最后是修改日期和项目的名字。 svn上传.so文件无效 通过终端打开配置文件: open ~/.subversion/config，把下面两行(也可能是一行)中的注释和*.so去掉，然后保存 # global-ignores = *.o *.lo *.la *.al .libs *.a *.pyc *.pyo __pycache__ 以后上传文件如果有.so .[0-9]需要专门 svn add 一下才能够正常上传 svn上传后可执行权限 svn上传文件后添加可执行权限 svn propset svn:executable on targetfile svn删除仓库中的文件可执行权限 svn propdel svn:executable targetfile Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 14:42:10 "},"Chapter/Linux/Python.html":{"url":"Chapter/Linux/Python.html","title":"python","keywords":"","body":"pip安装 pip安装Python库较慢时候可能因为超时造成安装失败，输入命令的时候使用--default-timeout参数指定超时时间 sudo pip --default-timeout=600 install Django Python支持中文 #coding=utf-8 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-05 14:18:12 "},"Chapter/Linux/C.html":{"url":"Chapter/Linux/C.html","title":"C语言相关","keywords":"","body":"C语言中的宏定义 众多C++书籍都忠告我们C语言宏是万恶之首，但事情总不如我们想象的那么坏，就如同goto一样。宏有一个很大的作用，就是自动为我们产生代码。如果说模板可以为我们产生各种型别的代码(型别替换)， 那么宏其实可以为我们在符号上产生新的代码(即符号替换、增加)。 关于宏的一些语法问题，可以在google上找到。相信我，你对于宏的了解绝对没你想象的那么多。如果你还不知道#和##，也不知道prescan，那么你肯定对宏的了解不够。 我稍微讲解下宏的一些语法问题(说语法问题似乎不妥，macro只与preprocessor有关，跟语义分析又无关)： 宏可以像函数一样被定义，例如： #define min(x,y) (x 但是在实际使用时，只有当写上min()，必须加括号，min才会被作为宏展开，否则不做任何处理。 如果宏需要参数，你可以不传，编译器会给你警告(宏参数不够)，但是这会导致错误。如C++书籍中所描述的，编译器(预处理器)对宏的语法检查不够，所以更多的检查性工作得你自己来做。 很多程序员不知道的#和## \"#\"符号把一个符号直接转换为字符串，例如： #define STRING(x) #x const char *str = STRING( test_string ); str的内容就是\"test_string\"，也就是说#会把其后的符号直接加上双引号。 \"##\"符号会连接两个符号，从而产生新的符号(词法层次)，例如： #define SIGN( x ) INT_##xint SIGN( 1 ); 宏被展开后将成为：int INT_1; 变参宏，这个比较酷，它使得你可以定义类似的宏： #define LOG( format, ... ) printf( format, __VA_ARGS__ ) LOG( \"%s %d\", str, count ); VA_ARGS是系统预定义宏，被自动替换为参数列表。 当一个宏自己调用自己时，会发生什么？例如： #define TEST( x ) ( x + TEST( x ) ) TEST( 1 ); 会发生什么？为了防止无限制递归展开，语法规定，当一个宏遇到自己时，就停止展开，也就是说，当对TEST( 1 )进行展开时，展开过程中又发现了一个TEST，那么就将这个TEST当作一般的符号。TEST(1)最终被展开为：1 + TEST( 1) 。 宏参数的prescan， 当一个宏参数被放进宏体时，这个宏参数会首先被全部展开(有例外，见下文)。当展开后的宏参数被放进宏体时， 预处理器对新展开的宏体进行第二次扫描，并继续展开。例如： #define PARAM( x ) x #define ADDPARAM( x ) INT_##x PARAM( ADDPARAM( 1 ) ); 因为ADDPARAM( 1 ) 是作为PARAM的宏参数，所以先将ADDPARAM( 1 )展开为INT_1，然后再将INT_1放进PARAM。 例外情况是，如果PARAM宏里对宏参数使用了#或##，那么宏参数不会被展开： #define PARAM( x ) #x #define ADDPARAM( x ) INT_##x PARAM( ADDPARAM( 1 ) ); 将被展开为\"ADDPARAM( 1 )\"。 使用这么一个规则，可以创建一个很有趣的技术：打印出一个宏被展开后的样子，这样可以方便你分析代码： #define TO_STRING( x ) TO_STRING1( x ) #define TO_STRING1( x ) #x TO_STRING首先会将x全部展开(如果x也是一个宏的话)，然后再传给TO_STRING1转换为字符串，现在你可以这样：const char *str = TO_STRING( PARAM( ADDPARAM( 1 ) ) );去一探PARAM展开后的样子。 一个很重要的补充：就像我在第一点说的那样，如果一个像函数的宏在使用时没有出现括号，那么预处理器只是将这个宏作为一般的符号处理(那就是不处理)。 我们来见识一下宏是如何帮助我们自动产生代码的。如我所说，宏是在符号层次产生代码。我在分析Boost.Function模块时，因为它使用了大量的宏(宏嵌套，再嵌套)，导致我压根没看明白代码。后来发现了一个小型的模板库ttl，说的是开发一些小型组件去取代部分Boost(这是一个好理由，因为Boost确实太大)。同样，这个库也包含了一个function库。 这里的function也就是我之前提到的functor。ttl.function库里为了自动产生很多类似的代码，使用了一个宏： #define TTL_FUNC_BUILD_FUNCTOR_CALLER(n) / template / struct functor_caller_base##n / ///... 该宏的最终目的是：通过类似于TTL_FUNC_BUILD_FUNCTOR_CALLER(1)的调用方式，自动产生很多functor_caller_base模板： template struct functor_caller_base1 template struct functor_caller_base2 template struct functor_caller_base3 ///... 那么，核心部分在于TTL_TPARAMS(n)这个宏，可以看出这个宏最终产生的是： typename T1 typename T1, typename T2 typename T1, typename T2, typename T3 ///... 我们不妨分析TTL_TPARAMS(n)的整个过程。分析宏主要把握我以上提到的一些要点即可。以下过程我建议你翻着ttl的代码，相关代码文件：function.hpp, macro_params.hpp, macro_repeat.hpp, macro_misc.hpp, macro_counter.hpp。 so, here we Go 分析过程，逐层分析，逐层展开，例如TTL_TPARAMS(1)： #define TTL_TPARAMS(n) TTL_TPARAMSX(n,T) => TTL_TPARAMSX( 1, T ) #define TTL_TPARAMSX(n,t) TTL_REPEAT(n, TTL_TPARAM, TTL_TPARAM_END, t) => TTL_REPEAT( 1, TTL_TPARAM, TTL_TPARAM_END, T ) #define TTL_TPARAM(n,t) typename t##n, #define TTL_TPARAM_END(n,t) typename t##n #define TTL_REPEAT(n, m, l, p) TTL_APPEND(TTL_REPEAT_, TTL_DEC(n))(m,l,p) TTL_APPEND(TTL_LAST_REPEAT_,n)(l,p) 注意，TTL_TPARAM, TTL_TPARAM_END虽然也是两个宏，他们被作为TTL_REPEAT宏的参数，按照prescan规则，似乎应该先将 这两个宏展开再传给TTL_REPEAT。但是，如同我在前面重点提到的，这两个宏是function-like macro，使用时需要加括号， 如果没加括号，则不当作宏处理。因此，展开TTL_REPEAT时，应该为： => TTL_APPEND( TTL_REPEAT_, TTL_DEC(1))(TTL_TPARAM,TTL_TPARAM_END,T) TTL_APPEND( TTL_LAST_REPEAT_,1)( TTL_TPARAM_END,T) 这个宏体看起来很复杂，仔细分析下，可以分为两部分： TTL_APPEND( TTL_REPEAT_, TTL_DEC(1))(TTL_TPARAM,TTL_TPARAM_END,T)以及 TTL_APPEND( TTL_LAST_REPEAT_,1)(TTL_TPARAM_END,T) 先分析第一部分： #define TTL_APPEND( x, y ) TTL_APPEND1(x,y) //先展开x,y再将x,y连接起来 #define TTL_APPEND1( x, y ) x ## y #define TTL_DEC(n) TTL_APPEND(TTL_CNTDEC_, n) 根据先展开参数的原则，会先展开TTL_DEC(1) => TTL_APPEND(TTL_CNTDEC_,1) => TTL_CNTDEC_1 #define TTL_CNTDEC_1 0 注意，TTL_CNTDEC_不是宏，TTL_CNTDEC_1是一个宏。 => 0 ， 也就是说，TTL_DEC(1)最终被展开为0。回到TTL_APPEND部分： => TTL_REPEAT_0 (TTL_TPARAM,TTL_TPARAM_END,T) #define TTL_REPEAT_0(m,l,p) TTL_REPEAT_0这个宏为空，那么，上面说的第一部分被忽略，现在只剩下第二部分： TTL_APPEND( TTL_LAST_REPEAT_,1)(TTL_TPARAM_END,T) => TTL_LAST_REPEAT_1 (TTL_TPARAM_END,T) // TTL_APPEND将TTL_LAST_REPEAT_和1合并起来 #define TTL_LAST_REPEAT_1(m,p) m(1,p) => TTL_TPARAM_END( 1, T ) #define TTL_TPARAM_END(n,t) typename t##n => typename T1 展开完毕。 虽然我们分析出来了，但是这其实并不是我们想要的。我们应该从那些宏里去获取作者关于宏的编程思想。很好地使用宏看上去似乎是一些偏门的奇技淫巧，但是他确实可以让我们编码更自动化。 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/Linux/errornum.html":{"url":"Chapter/Linux/errornum.html","title":"Linux错误码","keywords":"","body":"Linux 错误码 #ifndef _I386_ERRNO_H #define _I386_ERRNO_H #define EPERM 1 /* Operation not permitted */ #define ENOENT 2 /* No such file or directory */ #define ESRCH 3 /* No such process */ #define EINTR 4 /* Interrupted system call */ #define EIO 5 /* I/O error */ #define ENXIO 6 /* No such device or address */ #define E2BIG 7 /* Arg list too long */ #define ENOEXEC 8 /* Exec format error */ #define EBADF 9 /* Bad file number */ #define ECHILD 10 /* No child processes */ #define EAGAIN 11 /* Try again */ #define ENOMEM 12 /* Out of memory */ #define EACCES 13 /* Permission denied */ //这是我今天遇到的问题 #define EFAULT 14 /* Bad address */ #define ENOTBLK 15 /* Block device required */ #define EBUSY 16 /* Device or resource busy */ #define EEXIST 17 /* File exists */ #define EXDEV 18 /* Cross-device link */ #define ENODEV 19 /* No such device */ #define ENOTDIR 20 /* Not a directory */ #define EISDIR 21 /* Is a directory */ #define EINVAL 22 /* Invalid argument */ #define ENFILE 23 /* File table overflow */ #define EMFILE 24 /* Too many open files */ #define ENOTTY 25 /* Not a typewriter */ #define ETXTBSY 26 /* Text file busy */ #define EFBIG 27 /* File too large */ #define ENOSPC 28 /* No space left on device */ #define ESPIPE 29 /* Illegal seek */ #define EROFS 30 /* Read-only file system */ #define EMLINK 31 /* Too many links */ #define EPIPE 32 /* Broken pipe */ #define EDOM 33 /* Math argument out of domain of func */ #define ERANGE 34 /* Math result not representable */ #define EDEADLK 35 /* Resource deadlock would occur */ #define ENAMETOOLONG 36 /* File name too long */ #define ENOLCK 37 /* No record locks available */ #define ENOSYS 38 /* Function not implemented */ #define ENOTEMPTY 39 /* Directory not empty */ #define ELOOP 40 /* Too many symbolic links encountered */ #define EWOULDBLOCK EAGAIN /* Operation would block */ #define ENOMSG 42 /* No message of desired type */ #define EIDRM 43 /* Identifier removed */ #define ECHRNG 44 /* Channel number out of range */ #define EL2NSYNC 45 /* Level 2 not synchronized */ #define EL3HLT 46 /* Level 3 halted */ #define EL3RST 47 /* Level 3 reset */ #define ELNRNG 48 /* Link number out of range */ #define EUNATCH 49 /* Protocol driver not attached */ #define ENOCSI 50 /* No CSI structure available */ #define EL2HLT 51 /* Level 2 halted */ #define EBADE 52 /* Invalid exchange */ #define EBADR 53 /* Invalid request descriptor */ #define EXFULL 54 /* Exchange full */ #define ENOANO 55 /* No anode */ #define EBADRQC 56 /* Invalid request code */ #define EBADSLT 57 /* Invalid slot */ #define EDEADLOCK EDEADLK #define EBFONT 59 /* Bad font file format */ #define ENOSTR 60 /* Device not a stream */ #define ENODATA 61 /* No data available */ #define ETIME 62 /* Timer expired */ #define ENOSR 63 /* Out of streams resources */ #define ENONET 64 /* Machine is not on the network */ #define ENOPKG 65 /* Package not installed */ #define EREMOTE 66 /* Object is remote */ #define ENOLINK 67 /* Link has been severed */ #define EADV 68 /* Advertise error */ #define ESRMNT 69 /* Srmount error */ #define ECOMM 70 /* Communication error on send */ #define EPROTO 71 /* Protocol error */ #define EMULTIHOP 72 /* Multihop attempted */ #define EDOTDOT 73 /* RFS specific error */ #define EBADMSG 74 /* Not a data message */ #define EOVERFLOW 75 /* Value too large for defined data type */ #define ENOTUNIQ 76 /* Name not unique on network */ #define EBADFD 77 /* File descriptor in bad state */ #define EREMCHG 78 /* Remote address changed */ #define ELIBACC 79 /* Can not access a needed shared library */ #define ELIBBAD 80 /* Accessing a corrupted shared library */ #define ELIBSCN 81 /* .lib section in a.out corrupted */ #define ELIBMAX 82 /* Attempting to link in too many shared libraries */ #define ELIBEXEC 83 /* Cannot exec a shared library directly */ #define EILSEQ 84 /* Illegal byte sequence */ #define ERESTART 85 /* Interrupted system call should be restarted */ #define ESTRPIPE 86 /* Streams pipe error */ #define EUSERS 87 /* Too many users */ #define ENOTSOCK 88 /* Socket operation on non-socket */ #define EDESTADDRREQ 89 /* Destination address required */ #define EMSGSIZE 90 /* Message too long */ #define EPROTOTYPE 91 /* Protocol wrong type for socket */ #define ENOPROTOOPT 92 /* Protocol not available */ #define EPROTONOSUPPORT 93 /* Protocol not supported */ #define ESOCKTNOSUPPORT 94 /* Socket type not supported */ #define EOPNOTSUPP 95 /* Operation not supported on transport endpoint */ #define EPFNOSUPPORT 96 /* Protocol family not supported */ #define EAFNOSUPPORT 97 /* Address family not supported by protocol */ #define EADDRINUSE 98 /* Address already in use */ #define EADDRNOTAVAIL 99 /* Cannot assign requested address */ #define ENETDOWN 100 /* Network is down */ #define ENETUNREACH 101 /* Network is unreachable */ #define ENETRESET 102 /* Network dropped connection because of reset */ #define ECONNABORTED 103 /* Software caused connection abort */ #define ECONNRESET 104 /* Connection reset by peer */ #define ENOBUFS 105 /* No buffer space available */ #define EISCONN 106 /* Transport endpoint is already connected */ #define ENOTCONN 107 /* Transport endpoint is not connected */ #define ESHUTDOWN 108 /* Cannot send after transport endpoint shutdown */ #define ETOOMANYREFS 109 /* Too many references: cannot splice */ #define ETIMEDOUT 110 /* Connection timed out */ #define ECONNREFUSED 111 /* Connection refused */ #define EHOSTDOWN 112 /* Host is down */ #define EHOSTUNREACH 113 /* No route to host */ #define EALREADY 114 /* Operation already in progress */ #define EINPROGRESS 115 /* Operation now in progress */ #define ESTALE 116 /* Stale NFS file handle */ #define EUCLEAN 117 /* Structure needs cleaning */ #define ENOTNAM 118 /* Not a XENIX named type file */ #define ENAVAIL 119 /* No XENIX semaphores available */ #define EISNAM 120 /* Is a named type file */ #define EREMOTEIO 121 /* Remote I/O error */ #define EDQUOT 122 /* Quota exceeded */ #define ENOMEDIUM 123 /* No medium found */ #define EMEDIUMTYPE 124 /* Wrong medium type */ #define ECANCELED 125 /* Operation Canceled */ #define ENOKEY 126 /* Required key not available */ #define EKEYEXPIRED 127 /* Key has expired */ #define EKEYREVOKED 128 /* Key has been revoked */ #define EKEYREJECTED 129 /* Key was rejected by service */ /* for robust mutexes */ #define EOWNERDEAD 130 /* Owner died */ #define ENOTRECOVERABLE 131 /* State not recoverable */ #endif Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/Linux/timestamp.html":{"url":"Chapter/Linux/timestamp.html","title":"时间和时间戳","keywords":"","body":"Linux下时间和时间戳 网页连接 1.时间戳转格式化日期，比如：1384936600 → 2013-11-20 08:36:40 输入一个long，输出一个nsstring 2.反过来：2013-11-20 08:36:40 → 1384936600 输入nsstring，输出一个long 好久没碰C语言。。好多函数都现查怎么用，还好一会就搞定了 1.时间戳转格式化 #include #include int main(int argc, const char * argv[]) { time_t t; struct tm *p; t=1384936600; p=gmtime(&t); char s[100]; strftime(s, sizeof(s), \"%Y-%m-%d %H:%M:%S\", p); printf(\"%d: %s\\n\", (int)t, s); return 0; } 2.格式化转时间戳 #include #include int main(int argc, const char * argv[]) { struct tm* tmp_time = (struct tm*)malloc(sizeof(struct tm)); strptime(\"20131120\",\"%Y%m%d\",tmp_time); time_t t = mktime(tmp_time); printf(\"%ld\\n\",t); free(tmp_time); return 0; } Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/Linux/skills.html":{"url":"Chapter/Linux/skills.html","title":"技巧","keywords":"","body":"linux递归删除固定后缀名的文件 find . -name '*.exe' -type f -print -exec rm -rf {} \\; (1) \".\" 表示从当前目录开始递归查找 (2) “ -name '*.exe' \"根据名称来查找，要查找所有以.exe结尾的文件夹或者文件 (3) \" -type f \"查找的类型为文件 (4) \"-print\" 输出查找的文件目录名 (5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个\\，最后是一个分号 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/Linux/samba.html":{"url":"Chapter/Linux/samba.html","title":"Samba服务","keywords":"","body":"Samba服务器安装 1.安装Samba服务 sudo apt-get install samba 2.配置Samba服务 sudo vim /etc/samba/smb.conf 在最后加上 [smbshare] comment = smbshare home directory #一个标签，随便写 path = /home/zhanghao/sugon/project #Samba共享出来的目录，必须存在 browseable = yes #Samba浏览的权限 writeable = yes #Samba写权限 read = yes #Samba读权限 3.配置Samba用户权限 sudo smbpasswd -a zhanghao 会要求密码，设置一个访问的密码 4.重启服务 sudo /etc/init.d/smbd restart 5.windows访问 输入Win+R,利用下边的方式访问: \\ip 随后会需要刚才输入的用户名和密码 清空保存的用户名和密码用如下的方式 打开CMD命令行，输入以下命令：net use * /del来删除所有缓存的访问记录 创建网络位置，方便随时查看 在我的电脑处右键，选择\"添加一个网络位置\"，后续按照提示添加就可以 6.问题排查 上述配置后，Samba访问会很慢，并且经常伴随这没有权限，查看samba服务的日志（/var/log/samba/log.%m）会发现如下报错： 需要安装daemon sudo apt-get install daemon 安装完成后重启Samba服务，windows下访问如丝般流畅 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 14:41:23 "},"Chapter/Tools/Introduce.html":{"url":"Chapter/Tools/Introduce.html","title":"系统工具","keywords":"","body":"系统工具 本章节设计使用Linux过程中系统工具的知识 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/Tools/bcompare.html":{"url":"Chapter/Tools/bcompare.html","title":"Beyond Compare","keywords":"","body":"Beyond Compare 3 安装 DEBIAN, UBUNTU Beyond Compare 4.1 and newer require matching package and OS architecture (amd64.deb or i386.deb). Beyond Compare 3 - 4.0.7 require the i386.deb package on all supported versions of Debian and Ubuntu (32-bit and 64-bit). Beyond Compare 3 on Debian 7, 8 64-bit Enable 32-bit architecture support:sudo dpkg --add-architecture i386 Graphical Install Double click on the .deb package to install using the graphical package manager. Terminal Install sudo apt-get update sudo apt-get install gdebi sudo gdebi bcompare-4.1.6.21095_amd64.deb Terminal Uninstall sudo apt-get remove bcompare Beyond Compare 3 注册 Ubuntu 14.04安装Beyond Compare 3方法 注册码 HmB5oANygQOhaStTHNa+zOKgOeWHOkeAp6d1+QwIebz6z9kwYCm9-O0jF9F79zvzed9v5UVC4VrDkDMmTM8nB+ Beyond Comapre 4 破解方法 主机环境：ubuntu14.04LTS 软件环境：bcompare-4.1.6.21095_amd64.deb 辅助软件：wxhexeditor（可用sudo apt-get install wxhexeditor安装，不用可卸载） 网址：破解方法网址 Beyond Compare是一个非常强大的文件/文件夹比较工具，它支持Windows、Mac和Linux下运行；它是一个商业软件，需要付费才能长期使用它。如果你喜欢它，建议购买它。 安装后，备份/usr/lib/beyondcompare/BCompare， 这里用wxhexeditor编辑之前需要将该文件赋予写权限 用VIM+xxd或者MadEdit或者wxhexeditor打开这个文件，编辑替换如下地址的内容： offset start: 0x00162233 offset end: 0x00162387 size: 0x155 好像上边的地址和偏移没什么用，直接用下边的查找就可以 下面两种查找方式使用任意一种就可以 使用字符串查找替换如下： 查找串： keexjEP3t4Mue23hrnuPtY4TdcsqNiJL-5174TsUdLmJSIXKfG2NGPwBL6vnRPddT7tH29qpkneX63DO9ECSPE9rzY1zhThHERg8lHM9IBFT+rVuiY823aQJuqzxCKIE1bcDqM4wgW01FH6oCBP1G4ub01xmb4BGSUG6ZrjxWHJyNLyIlGvOhoY2HAYzEtzYGwxFZn2JZ66o4RONkXjX0DF9EzsdUef3UAS+JQ+fCYReLawdjEe6tXCv88GKaaPKWxCeaUL9PejICQgRQOLGOZtZQkLgAelrOtehxz5ANOOqCaJgy2mJLQVLM5SJ9Dli909c5ybvEhVmIC0dc9dWH 替换为： N9KmiLVlKMU7RJqnE+WXEEPI1SgglmfmLc1yVH7dqBb9ehOoKG9UE+HAE1YvH1XX2XVGeEqYUY-Tsk7YBTz0WpSpoYyPgx6Iki5KLtQ5G-aKP9eysnkuOAkrvHU8bLbGtZteGwJarev03PhfCioJL4OSqsmQGEvDbHFEbNl1qJtdwEriR+VNZts9vNNLk7UGfeNwIiqpxjk4Mn09nmSd8FhM4ifvcaIbNCRoMPGl6KU12iseSe+w+1kFsLhX+OhQM8WXcWV10cGqBzQE9OqOLUcg9n0krrR3KrohstS9smTwEx9olyLYppvC0p5i7dAx2deWvM1ZxKNs0BvcXGukR 使用十六进制查找替换如下： 查找： 6B 65 65 78 6A 45 50 33 74 34 4D 75 65 32 33 68 72 6E 75 50 74 59 34 54 64 63 73 71 4E 69 4A 4C 2D 35 31 37 34 54 73 55 64 4C 6D 4A 53 49 58 4B 66 47 32 4E 47 50 77 42 4C 36 76 6E 52 50 64 64 54 37 74 48 32 39 71 70 6B 6E 65 58 36 33 44 4F 39 45 43 53 50 45 39 72 7A 59 31 7A 68 54 68 48 45 52 67 38 6C 48 4D 39 49 42 46 54 2B 72 56 75 69 59 38 32 33 61 51 4A 75 71 7A 78 43 4B 49 45 31 62 63 44 71 4D 34 77 67 57 30 31 46 48 36 6F 43 42 50 31 47 34 75 62 30 31 78 6D 62 34 42 47 53 55 47 36 5A 72 6A 78 57 48 4A 79 4E 4C 79 49 6C 47 76 4F 68 6F 59 32 48 41 59 7A 45 74 7A 59 47 77 78 46 5A 6E 32 4A 5A 36 36 6F 34 52 4F 4E 6B 58 6A 58 30 44 46 39 45 7A 73 64 55 65 66 33 55 41 53 2B 4A 51 2B 66 43 59 52 65 4C 61 77 64 6A 45 65 36 74 58 43 76 38 38 47 4B 61 61 50 4B 57 78 43 65 61 55 4C 39 50 65 6A 49 43 51 67 52 51 4F 4C 47 4F 5A 74 5A 51 6B 4C 67 41 65 6C 72 4F 74 65 68 78 7A 35 41 4E 4F 4F 71 43 61 4A 67 79 32 6D 4A 4C 51 56 4C 4D 35 53 4A 39 44 6C 69 39 30 39 63 35 79 62 76 45 68 56 6D 49 43 30 64 63 39 64 57 48 替换为： 4E 39 4B 6D 69 4C 56 6C 4B 4D 55 37 52 4A 71 6E 45 2B 57 58 45 45 50 49 31 53 67 67 6C 6D 66 6D 4C 63 31 79 56 48 37 64 71 42 62 39 65 68 4F 6F 4B 47 39 55 45 2B 48 41 45 31 59 76 48 31 58 58 32 58 56 47 65 45 71 59 55 59 2D 54 73 6B 37 59 42 54 7A 30 57 70 53 70 6F 59 79 50 67 78 36 49 6B 69 35 4B 4C 74 51 35 47 2D 61 4B 50 39 65 79 73 6E 6B 75 4F 41 6B 72 76 48 55 38 62 4C 62 47 74 5A 74 65 47 77 4A 61 72 65 76 30 33 50 68 66 43 69 6F 4A 4C 34 4F 53 71 73 6D 51 47 45 76 44 62 48 46 45 62 4E 6C 31 71 4A 74 64 77 45 72 69 52 2B 56 4E 5A 74 73 39 76 4E 4E 4C 6B 37 55 47 66 65 4E 77 49 69 71 70 78 6A 6B 34 4D 6E 30 39 6E 6D 53 64 38 46 68 4D 34 69 66 76 63 61 49 62 4E 43 52 6F 4D 50 47 6C 36 4B 55 31 32 69 73 65 53 65 2B 77 2B 31 6B 46 73 4C 68 58 2B 4F 68 51 4D 38 57 58 63 57 56 31 30 63 47 71 42 7A 51 45 39 4F 71 4F 4C 55 63 67 39 6E 30 6B 72 72 52 33 4B 72 6F 68 73 74 53 39 73 6D 54 77 45 78 39 6F 6C 79 4C 59 70 70 76 43 30 70 35 69 37 64 41 78 32 64 65 57 76 4D 31 5A 78 4B 4E 73 30 42 76 63 58 47 75 6B 52 最后，使用如下注册码即可注册成功： --- BEGIN LICENSE KEY --- gCh0q+aTeOSxkmHm+dJdnNW+BX0mvx3Bi09VC9mSmGhN3I6qxcnk8QBLjq3Xl7A3iXCPncqflD9CXI+LONqH-Mnqe4DHXwQ7dHPvON0nqztC0hVH9Ynd8PCW0G2eN9PKiptFjaxxzulLqScDMmcR5BCx2bHes-kfzybCvhhv8yEDivZcUQACxYYWwcA49DCQOoDzwDXGJKZ7YwkZWgJfGzGSaxT546hP-5phfMQF5DHq47oGBtlmpyRu5P-taBJa+txla5fyl8w9+BcB4b9FvnooVzNohzbzbgDc6g0ABh4xVfGwNc+bj1obl6h3C5+FmCRffmqaRXnq108oYakpL+++ --- END LICENSE KEY ----- Beyond Compare 4 过期后处理方法 过期后处理方法网址 错误提示：This license key has been revoked xxxxx Windows 系统： 解决方法： 删除以下目录中的所有文件即可。 C:\\Users\\Administrator\\AppData\\Roaming\\Scooter Software\\Beyond Compare 4 Linux系统： 解决方法： 1.删除下面目录中的所有文件： /home/xxx/.config/bcompare 2.重新破解 $cd /usr/lib/beyondcompare/ $sudo sed -i \"s/keexjEP3t4Mue23hrnuPtY4TdcsqNiJL-5174TsUdLmJSIXKfG2NGPwBL6vnRPddT7tH29qpkneX63DO9ECSPE9rzY1zhThHERg8lHM9IBFT+rVuiY823aQJuqzxCKIE1bcDqM4wgW01FH6oCBP1G4ub01xmb4BGSUG6ZrjxWHJyNLyIlGvOhoY2HAYzEtzYGwxFZn2JZ66o4RONkXjX0DF9EzsdUef3UAS+JQ+fCYReLawdjEe6tXCv88GKaaPKWxCeaUL9PejICQgRQOLGOZtZQkLgAelrOtehxz5ANOOqCaJgy2mJLQVLM5SJ9Dli909c5ybvEhVmIC0dc9dWH+/N9KmiLVlKMU7RJqnE+WXEEPI1SgglmfmLc1yVH7dqBb9ehOoKG9UE+HAE1YvH1XX2XVGeEqYUY-Tsk7YBTz0WpSpoYyPgx6Iki5KLtQ5G-aKP9eysnkuOAkrvHU8bLbGtZteGwJarev03PhfCioJL4OSqsmQGEvDbHFEbNl1qJtdwEriR+VNZts9vNNLk7UGfeNwIiqpxjk4Mn09nmSd8FhM4ifvcaIbNCRoMPGl6KU12iseSe+w+1kFsLhX+OhQM8WXcWV10cGqBzQE9OqOLUcg9n0krrR3KrohstS9smTwEx9olyLYppvC0p5i7dAx2deWvM1ZxKNs0BvcXGukR+/g\" BCompare 3.此时BCompare文件已被破解，打开软件会提示“Trial Mode Error！”表示成功，输入下面TEAM ZWT生成的密钥即可注册成功 --- BEGIN LICENSE KEY --- GXN1eh9FbDiX1ACdd7XKMV7hL7x0ClBJLUJ-zFfKofjaj2yxE53xauIfkqZ8FoLpcZ0Ux6McTyNmODDSvSIHLYhg1QkTxjCeSCk6ARz0ABJcnUmd3dZYJNWFyJun14rmGByRnVPL49QH+Rs0kjRGKCB-cb8IT4Gf0Ue9WMQ1A6t31MO9jmjoYUeoUmbeAQSofvuK8GN1rLRv7WXfUJ0uyvYlGLqzq1ZoJAJDyo0Kdr4ThF-IXcv2cxVyWVW1SaMq8GFosDEGThnY7C-SgNXW30jqAOgiRjKKRX9RuNeDMFqgP2cuf0NMvyMrMScnM1ZyiAaJJtzbxqN5hZOMClUTE+++ --- END LICENSE KEY ----- Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 11:44:55 "},"Chapter/OpenBMC/Introduce.html":{"url":"Chapter/OpenBMC/Introduce.html","title":"OpenBMC","keywords":"","body":"OpenBMC 本章节涉及使用OpenBMC过程中的知识 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-06 17:27:07 "},"Chapter/OpenBMC/Environment.html":{"url":"Chapter/OpenBMC/Environment.html","title":"环境搭建","keywords":"","body":"Sugon OpenBMC下载与编译 第一步：克隆库文件 git clone git@10.0.27.57:/home/git/openbmc-sugon.git 密码：111 第二步：配置环境 建议使用一个干净的环境，防止出现库依赖的相关问题 sudo apt-get install -y git build-essential libsdl1.2-dev texinfo gawk chrpath diffstat 参考连接 第三步：编译 可以查看git目录下的howtouse 第一次编译的过程会很漫长，后续会加快 export TEMPLATECONF=meta-sugon/meta-demoboard/conf source openbmc-env bitbake obmc-phosphor-image 成功后会在openbmc-sugon/build/tmp/deploy/images/demoboard目录下看到一个文件 obmc-phosphor-image-demoboard-20190807031140.static.mtd 该文件名会随着编译的时间与工程名称改变 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-07 11:45:20 "},"Chapter/OpenBMC/QA.html":{"url":"Chapter/OpenBMC/QA.html","title":"问题与解答","keywords":"","body":"问题收集 Copyright © zhanghao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-09 09:57:06 "}}